/**
 * C# SDK Generator
 *
 * Generates production-ready C# SDKs with:
 * - Records and classes for type definitions
 * - Task-based async/await
 * - HttpClient for HTTP
 * - NuGet packaging
 * - Full type safety
 *
 * @module generators/csharp-generator
 */

import type { CanonicalSchema, TypeDefinition, EndpointDefinition } from '../types/canonical-schema.js';
import { TypeKind } from '../types/canonical-schema.js';
import { BaseGenerator, type GenerationOptions, type GenerationResult, type GeneratedFile } from './base-generator.js';
import { TypeMapper, TargetLanguage } from '../core/type-mapper.js';

/**
 * C# SDK Generator
 */
export class CSharpGenerator extends BaseGenerator {
  private typeMapper: TypeMapper;

  constructor(schema: CanonicalSchema, options: GenerationOptions) {
    super(schema, options);
    this.typeMapper = new TypeMapper(
      { language: TargetLanguage.CSharp },
      schema.types
    );
  }

  override getLanguage(): TargetLanguage {
    return TargetLanguage.CSharp;
  }

  getFormattedPackageName(): string {
    return this.toPascalCase(this.options.packageName).replace(/-/g, '');
  }

  protected getBuildCommand(): string {
    return 'dotnet build';
  }

  protected getTestCommand(): string {
    return 'dotnet test';
  }

  protected getPublishCommand(): string {
    return 'dotnet pack && dotnet nuget push';
  }

  protected getRegistryUrl(): string {
    return 'https://nuget.org';
  }

  /**
   * Generate complete C# SDK
   */
  async generate(): Promise<GenerationResult> {
    const files: GeneratedFile[] = [];
    const warnings: string[] = [];
    const errors: string[] = [];

    try {
      // Generate types
      files.push(...(await this.generateTypes()));

      // Generate client
      files.push(...(await this.generateClient()));

      // Generate .csproj
      files.push(await this.generateManifest());

      // Generate README
      files.push(await this.generateReadme());

      // Generate examples
      if (this.options.includeExamples) {
        files.push(...(await this.generateExamples()));
      }

      // Generate tests
      if (this.options.includeTests) {
        files.push(...(await this.generateTests()));
      }
    } catch (error) {
      errors.push(error instanceof Error ? error.message : String(error));
    }

    return {
      files,
      warnings,
      errors,
      buildCommand: this.getBuildCommand(),
      testCommand: this.getTestCommand(),
      publishCommand: this.getPublishCommand(),
      registryUrl: this.getRegistryUrl(),
    };
  }

  /**
   * Generate type definitions
   */
  protected async generateTypes(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];

    const modelsContent = this.generateModelsFile();
    files.push({
      path: 'Models.cs',
      content: modelsContent,
    });

    return files;
  }

  /**
   * Generate Models.cs
   */
  private generateModelsFile(): string {
    const lines: string[] = [];
    const namespace = this.getFormattedPackageName();

    lines.push('// Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push('');
    lines.push('using System;');
    lines.push('using System.Collections.Generic;');
    lines.push('using System.Text.Json.Serialization;');
    lines.push('');
    lines.push(`namespace ${namespace};`);
    lines.push('');

    // Generate each type
    for (const type of this.schema.types) {
      const typeCode = this.generateType(type);
      if (typeCode) {
        lines.push(typeCode);
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  /**
   * Generate a single type definition
   */
  private generateType(type: TypeDefinition): string {
    switch (type.kind) {
      case TypeKind.Object:
        return this.generateRecord(type);
      case TypeKind.Enum:
        return this.generateEnum(type);
      default:
        return '';
    }
  }

  /**
   * Generate record
   */
  private generateRecord(type: TypeDefinition): string {
    const lines: string[] = [];

    // Add documentation
    if (type.description) {
      lines.push('/// <summary>');
      lines.push(`/// ${type.description}`);
      lines.push('/// </summary>');
    }

    // Record declaration
    lines.push(`public record ${this.toPascalCase(type.name)}`);
    lines.push('{');

    // Properties
    if (type.kind === TypeKind.Object && type.properties) {
      for (const prop of type.properties) {
        const mappedType = this.typeMapper.mapTypeReference(prop.type);

        // Property documentation
        if (prop.description) {
          lines.push('\t/// <summary>');
          lines.push(`\t/// ${prop.description}`);
          lines.push('\t/// </summary>');
        }

        // Handle optional fields with nullable
        const isOptional = !prop.required;
        let propertyType = mappedType.type;

        // Make optional fields nullable (except for reference types which are already nullable)
        if (isOptional && !propertyType.endsWith('?') && !propertyType.startsWith('List<') && !propertyType.startsWith('Dictionary<')) {
          const isValueType = ['int', 'long', 'double', 'float', 'bool', 'DateTime'].includes(propertyType);
          if (isValueType) {
            propertyType = propertyType + '?';
          }
        }

        const propertyName = this.toPascalCase(prop.name);
        const jsonName = prop.name;

        lines.push(`\t[JsonPropertyName("${jsonName}")]`);
        lines.push(`\tpublic ${propertyType} ${propertyName} { get; init; }`);
        lines.push('');
      }
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate enum
   */
  private generateEnum(type: TypeDefinition): string {
    const lines: string[] = [];

    // Add documentation
    if (type.description) {
      lines.push('/// <summary>');
      lines.push(`/// ${type.description}`);
      lines.push('/// </summary>');
    }

    // Enum declaration (using string enum pattern)
    const enumName = this.toPascalCase(type.name);
    lines.push(`public enum ${enumName}`);
    lines.push('{');

    // Values
    if (type.kind === TypeKind.Enum && type.values) {
      for (let i = 0; i < type.values.length; i++) {
        const value = type.values[i]!;

        if (value.description) {
          lines.push('\t/// <summary>');
          lines.push(`\t/// ${value.description}`);
          lines.push('\t/// </summary>');
        }

        const memberName = this.toPascalCase(String(value.value));
        lines.push(`\t[JsonPropertyName("${value.value}")]`);
        lines.push(`\t${memberName}${i < type.values.length - 1 ? ',' : ''}`);
      }
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate HTTP client
   */
  protected async generateClient(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];

    const clientContent = this.generateClientFile();
    files.push({
      path: 'Client.cs',
      content: clientContent,
    });

    return files;
  }

  /**
   * Generate Client.cs
   */
  private generateClientFile(): string {
    const lines: string[] = [];
    const namespace = this.getFormattedPackageName();

    lines.push('// Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push('');
    lines.push('using System;');
    lines.push('using System.Net.Http;');
    lines.push('using System.Net.Http.Headers;');
    lines.push('using System.Net.Http.Json;');
    lines.push('using System.Threading;');
    lines.push('using System.Threading.Tasks;');
    lines.push('');
    lines.push(`namespace ${namespace};`);
    lines.push('');

    // Config class
    lines.push('/// <summary>');
    lines.push('/// Client configuration');
    lines.push('/// </summary>');
    lines.push('public class ClientConfig');
    lines.push('{');
    lines.push('\t/// <summary>');
    lines.push('\t/// API key for authentication');
    lines.push('\t/// </summary>');
    lines.push('\tpublic string ApiKey { get; set; } = string.Empty;');
    lines.push('');
    lines.push('\t/// <summary>');
    lines.push('\t/// Base URL for the API');
    lines.push('\t/// </summary>');
    lines.push('\tpublic string BaseUrl { get; set; } = "https://api.example.com";');
    lines.push('');
    lines.push('\t/// <summary>');
    lines.push('\t/// Request timeout');
    lines.push('\t/// </summary>');
    lines.push('\tpublic TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(60);');
    lines.push('}');
    lines.push('');

    // Client class
    lines.push('/// <summary>');
    lines.push('/// API Client');
    lines.push('/// </summary>');
    lines.push('public class Client : IDisposable');
    lines.push('{');
    lines.push('\tprivate readonly ClientConfig _config;');
    lines.push('\tprivate readonly HttpClient _httpClient;');
    lines.push('\tprivate bool _disposed;');
    lines.push('');

    // Constructor
    lines.push('\t/// <summary>');
    lines.push('\t/// Creates a new client with the given API key');
    lines.push('\t/// </summary>');
    lines.push('\tpublic Client(string apiKey)');
    lines.push('\t\t: this(new ClientConfig { ApiKey = apiKey })');
    lines.push('\t{');
    lines.push('\t}');
    lines.push('');

    lines.push('\t/// <summary>');
    lines.push('\t/// Creates a new client with custom configuration');
    lines.push('\t/// </summary>');
    lines.push('\tpublic Client(ClientConfig config)');
    lines.push('\t{');
    lines.push('\t\t_config = config;');
    lines.push('\t\t_httpClient = new HttpClient');
    lines.push('\t\t{');
    lines.push('\t\t\tBaseAddress = new Uri(_config.BaseUrl),');
    lines.push('\t\t\tTimeout = _config.Timeout');
    lines.push('\t\t};');
    lines.push('');
    lines.push('\t\t_httpClient.DefaultRequestHeaders.Authorization =');
    lines.push('\t\t\tnew AuthenticationHeaderValue("Bearer", _config.ApiKey);');
    lines.push('\t\t_httpClient.DefaultRequestHeaders.Accept.Add(');
    lines.push('\t\t\tnew MediaTypeWithQualityHeaderValue("application/json"));');
    lines.push('\t}');
    lines.push('');

    // Generate endpoint methods
    for (const endpoint of this.schema.endpoints) {
      lines.push(this.generateEndpointMethod(endpoint));
      lines.push('');
    }

    // Helper request method
    lines.push('\t/// <summary>');
    lines.push('\t/// Makes an HTTP request');
    lines.push('\t/// </summary>');
    lines.push('\tprivate async Task<TResponse> RequestAsync<TResponse>(');
    lines.push('\t\tHttpMethod method,');
    lines.push('\t\tstring path,');
    lines.push('\t\tobject? body = null,');
    lines.push('\t\tCancellationToken cancellationToken = default)');
    lines.push('\t{');
    lines.push('\t\tvar request = new HttpRequestMessage(method, path);');
    lines.push('');
    lines.push('\t\tif (body != null)');
    lines.push('\t\t{');
    lines.push('\t\t\trequest.Content = JsonContent.Create(body);');
    lines.push('\t\t}');
    lines.push('');
    lines.push('\t\tvar response = await _httpClient.SendAsync(request, cancellationToken);');
    lines.push('');
    lines.push('\t\tif (!response.IsSuccessStatusCode)');
    lines.push('\t\t{');
    lines.push('\t\t\tvar error = await response.Content.ReadAsStringAsync(cancellationToken);');
    lines.push('\t\t\tthrow new HttpRequestException(');
    lines.push('\t\t\t\t$"API error ({response.StatusCode}): {error}");');
    lines.push('\t\t}');
    lines.push('');
    lines.push('\t\treturn await response.Content.ReadFromJsonAsync<TResponse>(cancellationToken: cancellationToken)');
    lines.push('\t\t\t?? throw new InvalidOperationException("Response was null");');
    lines.push('\t}');
    lines.push('');

    // Dispose
    lines.push('\t/// <summary>');
    lines.push('\t/// Disposes the client');
    lines.push('\t/// </summary>');
    lines.push('\tpublic void Dispose()');
    lines.push('\t{');
    lines.push('\t\tif (_disposed) return;');
    lines.push('\t\t_httpClient?.Dispose();');
    lines.push('\t\t_disposed = true;');
    lines.push('\t\tGC.SuppressFinalize(this);');
    lines.push('\t}');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate endpoint method
   */
  private generateEndpointMethod(endpoint: EndpointDefinition): string {
    const lines: string[] = [];

    // Documentation
    const methodName = this.toPascalCase(endpoint.operationId);
    lines.push('\t/// <summary>');
    if (endpoint.description) {
      lines.push(`\t/// ${endpoint.description}`);
    } else {
      lines.push(`\t/// ${methodName}`);
    }
    lines.push('\t/// </summary>');

    // Method signature
    const responseType = endpoint.responses.find(r => r.statusCode === 200);
    const returnType = responseType?.type
      ? this.typeMapper.mapTypeReference(responseType.type).type
      : 'object';

    lines.push(`\tpublic async Task<${returnType}> ${methodName}Async(`);

    // Parameters
    if (endpoint.requestBody) {
      const bodyType = this.typeMapper.mapTypeReference(endpoint.requestBody.type);
      lines[lines.length - 1] += `${bodyType.type} request, `;
    }

    lines[lines.length - 1] += 'CancellationToken cancellationToken = default)';

    lines.push('\t{');

    // Method body
    const httpMethod = endpoint.method.toUpperCase();
    const path = endpoint.path;

    if (endpoint.requestBody) {
      lines.push(`\t\treturn await RequestAsync<${returnType}>(`);
      lines.push(`\t\t\tHttpMethod.${this.toPascalCase(httpMethod)},`);
      lines.push(`\t\t\t"${path}",`);
      lines.push('\t\t\trequest,');
      lines.push('\t\t\tcancellationToken);');
    } else {
      lines.push(`\t\treturn await RequestAsync<${returnType}>(`);
      lines.push(`\t\t\tHttpMethod.${this.toPascalCase(httpMethod)},`);
      lines.push(`\t\t\t"${path}",`);
      lines.push('\t\t\tcancellationToken: cancellationToken);');
    }

    lines.push('\t}');

    return lines.join('\n');
  }

  /**
   * Generate .csproj
   */
  protected async generateManifest(): Promise<GeneratedFile> {
    const packageName = this.getFormattedPackageName();
    const lines: string[] = [];

    lines.push('<Project Sdk="Microsoft.NET.Sdk">');
    lines.push('');
    lines.push('  <PropertyGroup>');
    lines.push('    <TargetFramework>net8.0</TargetFramework>');
    lines.push('    <LangVersion>latest</LangVersion>');
    lines.push('    <Nullable>enable</Nullable>');
    lines.push('    <ImplicitUsings>enable</ImplicitUsings>');
    lines.push(`    <PackageId>${packageName}</PackageId>`);
    lines.push(`    <Version>${this.options.packageVersion}</Version>`);
    if (this.schema.metadata.metadata?.['description']) {
      lines.push(`    <Description>${this.schema.metadata.metadata['description']}</Description>`);
    }
    lines.push(`    <PackageLicenseExpression>${this.options.license}</PackageLicenseExpression>`);
    lines.push('  </PropertyGroup>');
    lines.push('');
    lines.push('  <ItemGroup>');
    lines.push('    <PackageReference Include="System.Text.Json" Version="8.0.0" />');
    lines.push('  </ItemGroup>');
    lines.push('');
    lines.push('</Project>');

    return {
      path: `${packageName}.csproj`,
      content: lines.join('\n'),
    };
  }

  /**
   * Generate README
   */
  protected async generateReadme(): Promise<GeneratedFile> {
    const packageName = this.getFormattedPackageName();
    const lines: string[] = [];

    lines.push(`# ${this.schema.metadata.providerName} C# SDK`);
    lines.push('');
    if (this.schema.metadata.metadata?.['description']) {
      lines.push(String(this.schema.metadata.metadata['description']));
      lines.push('');
    }
    lines.push('Auto-generated by LLM-Forge.');
    lines.push('');

    lines.push('## Installation');
    lines.push('');
    lines.push('```bash');
    lines.push(`dotnet add package ${packageName}`);
    lines.push('```');
    lines.push('');

    lines.push('## Usage');
    lines.push('');
    lines.push('```csharp');
    lines.push(`using ${packageName};`);
    lines.push('');
    lines.push('var client = new Client("your-api-key");');
    lines.push('// Use the client...');
    lines.push('```');

    return {
      path: 'README.md',
      content: lines.join('\n'),
    };
  }

  /**
   * Generate examples
   */
  protected override async generateExamples(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const packageName = this.getFormattedPackageName();

    const lines: string[] = [];
    lines.push(`using ${packageName};`);
    lines.push('');
    lines.push('// Create a client');
    lines.push('using var client = new Client("your-api-key");');
    lines.push('');
    lines.push('// Example API call');
    lines.push('// var response = await client.SomeMethodAsync(request);');

    files.push({
      path: 'Examples/Basic.cs',
      content: lines.join('\n'),
    });

    return files;
  }

  /**
   * Generate tests
   */
  protected override async generateTests(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const packageName = this.getFormattedPackageName();

    const lines: string[] = [];
    lines.push('using Xunit;');
    lines.push(`using ${packageName};`);
    lines.push('');
    lines.push('public class ClientTests');
    lines.push('{');
    lines.push('\t[Fact]');
    lines.push('\tpublic void Client_CanBeCreated()');
    lines.push('\t{');
    lines.push('\t\tvar client = new Client("test-key");');
    lines.push('\t\tAssert.NotNull(client);');
    lines.push('\t}');
    lines.push('}');

    files.push({
      path: 'Tests/ClientTests.cs',
      content: lines.join('\n'),
    });

    return files;
  }
}
