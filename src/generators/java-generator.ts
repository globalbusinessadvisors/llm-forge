/**
 * Java SDK Generator
 *
 * Generates production-ready Java SDKs with:
 * - POJOs/Records for type definitions
 * - CompletableFuture for async operations
 * - HttpClient for HTTP
 * - Maven packaging
 * - Full type safety
 *
 * @module generators/java-generator
 */

import type { CanonicalSchema, TypeDefinition, EndpointDefinition } from '../types/canonical-schema.js';
import { TypeKind } from '../types/canonical-schema.js';
import { BaseGenerator, type GenerationOptions, type GenerationResult, type GeneratedFile } from './base-generator.js';
import { TypeMapper, TargetLanguage } from '../core/type-mapper.js';

/**
 * Java SDK Generator
 */
export class JavaGenerator extends BaseGenerator {
  private typeMapper: TypeMapper;

  constructor(schema: CanonicalSchema, options: GenerationOptions) {
    super(schema, options);
    this.typeMapper = new TypeMapper(
      { language: TargetLanguage.Java },
      schema.types
    );
  }

  override getLanguage(): TargetLanguage {
    return TargetLanguage.Java;
  }

  getFormattedPackageName(): string {
    return 'com.example.' + this.toSnakeCase(this.options.packageName).replace(/-/g, '').toLowerCase();
  }

  protected getBuildCommand(): string {
    return 'mvn clean package';
  }

  protected getTestCommand(): string {
    return 'mvn test';
  }

  protected getPublishCommand(): string {
    return 'mvn deploy';
  }

  protected getRegistryUrl(): string {
    return 'https://central.sonatype.com';
  }

  /**
   * Get base path for source files
   */
  private getSourcePath(): string {
    return 'src/main/java/' + this.getFormattedPackageName().replace(/\./g, '/');
  }

  /**
   * Generate complete Java SDK
   */
  async generate(): Promise<GenerationResult> {
    const files: GeneratedFile[] = [];
    const warnings: string[] = [];
    const errors: string[] = [];

    try {
      // Generate types
      files.push(...(await this.generateTypes()));

      // Generate client
      files.push(...(await this.generateClient()));

      // Generate pom.xml
      files.push(await this.generateManifest());

      // Generate README
      files.push(await this.generateReadme());

      // Generate examples
      if (this.options.includeExamples) {
        files.push(...(await this.generateExamples()));
      }

      // Generate tests
      if (this.options.includeTests) {
        files.push(...(await this.generateTests()));
      }
    } catch (error) {
      errors.push(error instanceof Error ? error.message : String(error));
    }

    return {
      files,
      warnings,
      errors,
      buildCommand: this.getBuildCommand(),
      testCommand: this.getTestCommand(),
      publishCommand: this.getPublishCommand(),
      registryUrl: this.getRegistryUrl(),
    };
  }

  /**
   * Generate type definitions
   */
  protected async generateTypes(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const basePath = this.getSourcePath();

    // Generate each type in its own file
    for (const type of this.schema.types) {
      const typeCode = this.generateType(type);
      if (typeCode) {
        files.push({
          path: `${basePath}/models/${this.toPascalCase(type.name)}.java`,
          content: typeCode,
        });
      }
    }

    return files;
  }

  /**
   * Generate a single type definition
   */
  private generateType(type: TypeDefinition): string {
    switch (type.kind) {
      case TypeKind.Object:
        return this.generateClass(type);
      case TypeKind.Enum:
        return this.generateEnum(type);
      default:
        return '';
    }
  }

  /**
   * Generate class
   */
  private generateClass(type: TypeDefinition): string {
    const lines: string[] = [];
    const packageName = this.getFormattedPackageName();

    lines.push(`package ${packageName}.models;`);
    lines.push('');
    lines.push('import com.fasterxml.jackson.annotation.JsonProperty;');
    lines.push('import java.util.List;');
    lines.push('import java.util.Map;');
    lines.push('');

    // Add Javadoc
    lines.push('/**');
    if (type.description) {
      lines.push(` * ${type.description}`);
    } else {
      lines.push(` * ${this.toPascalCase(type.name)}`);
    }
    lines.push(' *');
    lines.push(' * Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push(' */');

    // Class declaration (using record for immutability)
    const className = this.toPascalCase(type.name);
    lines.push(`public record ${className}(`);

    // Properties
    if (type.kind === TypeKind.Object && type.properties) {
      for (let i = 0; i < type.properties.length; i++) {
        const prop = type.properties[i]!;
        const mappedType = this.typeMapper.mapTypeReference(prop.type);

        const fieldName = this.toCamelCase(prop.name);
        const jsonName = prop.name;
        const comma = i < type.properties.length - 1 ? ',' : '';

        lines.push(`\t@JsonProperty("${jsonName}")`);
        lines.push(`\t${mappedType.type} ${fieldName}${comma}`);
      }
    }

    lines.push(') {}');

    return lines.join('\n');
  }

  /**
   * Generate enum
   */
  private generateEnum(type: TypeDefinition): string {
    const lines: string[] = [];
    const packageName = this.getFormattedPackageName();

    lines.push(`package ${packageName}.models;`);
    lines.push('');
    lines.push('import com.fasterxml.jackson.annotation.JsonValue;');
    lines.push('');

    // Add Javadoc
    lines.push('/**');
    if (type.description) {
      lines.push(` * ${type.description}`);
    } else {
      lines.push(` * ${this.toPascalCase(type.name)}`);
    }
    lines.push(' *');
    lines.push(' * Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push(' */');

    // Enum declaration
    const enumName = this.toPascalCase(type.name);
    lines.push(`public enum ${enumName} {`);

    // Values
    if (type.kind === TypeKind.Enum && type.values) {
      for (let i = 0; i < type.values.length; i++) {
        const value = type.values[i]!;
        const memberName = this.toUpperSnakeCase(String(value.value));
        const jsonValue = value.value;

        lines.push(`\t${memberName}("${jsonValue}")${i < type.values.length - 1 ? ',' : ';'}`);
      }
    }

    lines.push('');
    lines.push('\tprivate final String value;');
    lines.push('');
    lines.push(`\t${enumName}(String value) {`);
    lines.push('\t\tthis.value = value;');
    lines.push('\t}');
    lines.push('');
    lines.push('\t@JsonValue');
    lines.push('\tpublic String getValue() {');
    lines.push('\t\treturn value;');
    lines.push('\t}');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate HTTP client
   */
  protected async generateClient(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const basePath = this.getSourcePath();

    // Generate Client.java
    const clientContent = this.generateClientFile();
    files.push({
      path: `${basePath}/Client.java`,
      content: clientContent,
    });

    // Generate ClientConfig.java
    const configContent = this.generateConfigFile();
    files.push({
      path: `${basePath}/ClientConfig.java`,
      content: configContent,
    });

    return files;
  }

  /**
   * Generate ClientConfig.java
   */
  private generateConfigFile(): string {
    const lines: string[] = [];
    const packageName = this.getFormattedPackageName();

    lines.push(`package ${packageName};`);
    lines.push('');
    lines.push('import java.time.Duration;');
    lines.push('');

    lines.push('/**');
    lines.push(' * Client configuration');
    lines.push(' *');
    lines.push(' * Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push(' */');
    lines.push('public class ClientConfig {');
    lines.push('\tprivate String apiKey;');
    lines.push('\tprivate String baseUrl;');
    lines.push('\tprivate Duration timeout;');
    lines.push('');

    lines.push('\tpublic ClientConfig() {');
    lines.push('\t\tthis.baseUrl = "https://api.example.com";');
    lines.push('\t\tthis.timeout = Duration.ofSeconds(60);');
    lines.push('\t}');
    lines.push('');

    lines.push('\tpublic String getApiKey() {');
    lines.push('\t\treturn apiKey;');
    lines.push('\t}');
    lines.push('');

    lines.push('\tpublic void setApiKey(String apiKey) {');
    lines.push('\t\tthis.apiKey = apiKey;');
    lines.push('\t}');
    lines.push('');

    lines.push('\tpublic String getBaseUrl() {');
    lines.push('\t\treturn baseUrl;');
    lines.push('\t}');
    lines.push('');

    lines.push('\tpublic void setBaseUrl(String baseUrl) {');
    lines.push('\t\tthis.baseUrl = baseUrl;');
    lines.push('\t}');
    lines.push('');

    lines.push('\tpublic Duration getTimeout() {');
    lines.push('\t\treturn timeout;');
    lines.push('\t}');
    lines.push('');

    lines.push('\tpublic void setTimeout(Duration timeout) {');
    lines.push('\t\tthis.timeout = timeout;');
    lines.push('\t}');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate Client.java
   */
  private generateClientFile(): string {
    const lines: string[] = [];
    const packageName = this.getFormattedPackageName();

    lines.push(`package ${packageName};`);
    lines.push('');
    lines.push('import com.fasterxml.jackson.databind.ObjectMapper;');
    lines.push('import java.net.URI;');
    lines.push('import java.net.http.HttpClient;');
    lines.push('import java.net.http.HttpRequest;');
    lines.push('import java.net.http.HttpResponse;');
    lines.push('import java.util.concurrent.CompletableFuture;');
    lines.push(`import ${packageName}.models.*;`);
    lines.push('');

    lines.push('/**');
    lines.push(' * API Client');
    lines.push(' *');
    lines.push(' * Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push(' */');
    lines.push('public class Client {');
    lines.push('\tprivate final ClientConfig config;');
    lines.push('\tprivate final HttpClient httpClient;');
    lines.push('\tprivate final ObjectMapper objectMapper;');
    lines.push('');

    // Constructor with API key
    lines.push('\t/**');
    lines.push('\t * Creates a new client with the given API key');
    lines.push('\t */');
    lines.push('\tpublic Client(String apiKey) {');
    lines.push('\t\tthis.config = new ClientConfig();');
    lines.push('\t\tthis.config.setApiKey(apiKey);');
    lines.push('\t\tthis.httpClient = HttpClient.newBuilder()');
    lines.push('\t\t\t.connectTimeout(config.getTimeout())');
    lines.push('\t\t\t.build();');
    lines.push('\t\tthis.objectMapper = new ObjectMapper();');
    lines.push('\t}');
    lines.push('');

    // Constructor with config
    lines.push('\t/**');
    lines.push('\t * Creates a new client with custom configuration');
    lines.push('\t */');
    lines.push('\tpublic Client(ClientConfig config) {');
    lines.push('\t\tthis.config = config;');
    lines.push('\t\tthis.httpClient = HttpClient.newBuilder()');
    lines.push('\t\t\t.connectTimeout(config.getTimeout())');
    lines.push('\t\t\t.build();');
    lines.push('\t\tthis.objectMapper = new ObjectMapper();');
    lines.push('\t}');
    lines.push('');

    // Generate endpoint methods
    for (const endpoint of this.schema.endpoints) {
      lines.push(this.generateEndpointMethod(endpoint));
      lines.push('');
    }

    // Helper request method
    lines.push('\t/**');
    lines.push('\t * Makes an HTTP request');
    lines.push('\t */');
    lines.push('\tprivate <T> CompletableFuture<T> request(');
    lines.push('\t\t\tString method,');
    lines.push('\t\t\tString path,');
    lines.push('\t\t\tObject body,');
    lines.push('\t\t\tClass<T> responseType) {');
    lines.push('\t\ttry {');
    lines.push('\t\t\tString url = config.getBaseUrl() + path;');
    lines.push('');
    lines.push('\t\t\tHttpRequest.Builder requestBuilder = HttpRequest.newBuilder()');
    lines.push('\t\t\t\t.uri(URI.create(url))');
    lines.push('\t\t\t\t.header("Authorization", "Bearer " + config.getApiKey())');
    lines.push('\t\t\t\t.header("Content-Type", "application/json");');
    lines.push('');
    lines.push('\t\t\tif (body != null) {');
    lines.push('\t\t\t\tString jsonBody = objectMapper.writeValueAsString(body);');
    lines.push('\t\t\t\trequestBuilder.method(method, HttpRequest.BodyPublishers.ofString(jsonBody));');
    lines.push('\t\t\t} else {');
    lines.push('\t\t\t\trequestBuilder.method(method, HttpRequest.BodyPublishers.noBody());');
    lines.push('\t\t\t}');
    lines.push('');
    lines.push('\t\t\tHttpRequest request = requestBuilder.build();');
    lines.push('');
    lines.push('\t\t\treturn httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())');
    lines.push('\t\t\t\t.thenApply(response -> {');
    lines.push('\t\t\t\t\tif (response.statusCode() < 200 || response.statusCode() >= 300) {');
    lines.push('\t\t\t\t\t\tthrow new RuntimeException(');
    lines.push('\t\t\t\t\t\t\t"API error (" + response.statusCode() + "): " + response.body());');
    lines.push('\t\t\t\t\t}');
    lines.push('\t\t\t\t\ttry {');
    lines.push('\t\t\t\t\t\treturn objectMapper.readValue(response.body(), responseType);');
    lines.push('\t\t\t\t\t} catch (Exception e) {');
    lines.push('\t\t\t\t\t\tthrow new RuntimeException("Failed to parse response", e);');
    lines.push('\t\t\t\t\t}');
    lines.push('\t\t\t\t});');
    lines.push('\t\t} catch (Exception e) {');
    lines.push('\t\t\treturn CompletableFuture.failedFuture(e);');
    lines.push('\t\t}');
    lines.push('\t}');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate endpoint method
   */
  private generateEndpointMethod(endpoint: EndpointDefinition): string {
    const lines: string[] = [];

    // Documentation
    const methodName = this.toCamelCase(endpoint.operationId);
    lines.push('\t/**');
    if (endpoint.description) {
      lines.push(`\t * ${endpoint.description}`);
    } else {
      lines.push(`\t * ${methodName}`);
    }
    lines.push('\t */');

    // Method signature
    const responseType = endpoint.responses.find(r => r.statusCode === 200);
    const returnType = responseType?.type
      ? this.typeMapper.mapTypeReference(responseType.type).type
      : 'Object';

    lines.push(`\tpublic CompletableFuture<${returnType}> ${methodName}(`);

    // Parameters
    if (endpoint.requestBody) {
      const bodyType = this.typeMapper.mapTypeReference(endpoint.requestBody.type);
      lines[lines.length - 1] += `${bodyType.type} request`;
    }

    lines[lines.length - 1] += ') {';

    // Method body
    const httpMethod = endpoint.method.toUpperCase();
    const path = endpoint.path;

    if (endpoint.requestBody) {
      lines.push(`\t\treturn request("${httpMethod}", "${path}", request, ${returnType}.class);`);
    } else {
      lines.push(`\t\treturn request("${httpMethod}", "${path}", null, ${returnType}.class);`);
    }

    lines.push('\t}');

    return lines.join('\n');
  }

  /**
   * Generate pom.xml
   */
  protected async generateManifest(): Promise<GeneratedFile> {
    const groupId = 'com.example';
    const artifactId = this.toSnakeCase(this.options.packageName).replace(/-/g, '').toLowerCase();
    const lines: string[] = [];

    lines.push('<?xml version="1.0" encoding="UTF-8"?>');
    lines.push('<project xmlns="http://maven.apache.org/POM/4.0.0"');
    lines.push('         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"');
    lines.push('         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0');
    lines.push('         http://maven.apache.org/xsd/maven-4.0.0.xsd">');
    lines.push('    <modelVersion>4.0.0</modelVersion>');
    lines.push('');
    lines.push(`    <groupId>${groupId}</groupId>`);
    lines.push(`    <artifactId>${artifactId}</artifactId>`);
    lines.push(`    <version>${this.options.packageVersion}</version>`);
    lines.push('    <packaging>jar</packaging>');
    lines.push('');
    if (this.schema.metadata.metadata?.['title']) {
      lines.push(`    <name>${this.schema.metadata.metadata['title']}</name>`);
    }
    if (this.schema.metadata.metadata?.['description']) {
      lines.push(`    <description>${this.schema.metadata.metadata['description']}</description>`);
    }
    lines.push('');
    lines.push('    <properties>');
    lines.push('        <maven.compiler.source>17</maven.compiler.source>');
    lines.push('        <maven.compiler.target>17</maven.compiler.target>');
    lines.push('        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>');
    lines.push('    </properties>');
    lines.push('');
    lines.push('    <dependencies>');
    lines.push('        <dependency>');
    lines.push('            <groupId>com.fasterxml.jackson.core</groupId>');
    lines.push('            <artifactId>jackson-databind</artifactId>');
    lines.push('            <version>2.15.2</version>');
    lines.push('        </dependency>');
    lines.push('        <dependency>');
    lines.push('            <groupId>org.junit.jupiter</groupId>');
    lines.push('            <artifactId>junit-jupiter</artifactId>');
    lines.push('            <version>5.10.0</version>');
    lines.push('            <scope>test</scope>');
    lines.push('        </dependency>');
    lines.push('    </dependencies>');
    lines.push('');
    lines.push('    <build>');
    lines.push('        <plugins>');
    lines.push('            <plugin>');
    lines.push('                <groupId>org.apache.maven.plugins</groupId>');
    lines.push('                <artifactId>maven-compiler-plugin</artifactId>');
    lines.push('                <version>3.11.0</version>');
    lines.push('            </plugin>');
    lines.push('        </plugins>');
    lines.push('    </build>');
    lines.push('</project>');

    return {
      path: 'pom.xml',
      content: lines.join('\n'),
    };
  }

  /**
   * Generate README
   */
  protected async generateReadme(): Promise<GeneratedFile> {
    const artifactId = this.toSnakeCase(this.options.packageName).replace(/-/g, '').toLowerCase();
    const lines: string[] = [];

    lines.push(`# ${this.schema.metadata.providerName} Java SDK`);
    lines.push('');
    if (this.schema.metadata.metadata?.['description']) {
      lines.push(String(this.schema.metadata.metadata['description']));
      lines.push('');
    }
    lines.push('Auto-generated by LLM-Forge.');
    lines.push('');

    lines.push('## Installation');
    lines.push('');
    lines.push('Add to your `pom.xml`:');
    lines.push('');
    lines.push('```xml');
    lines.push('<dependency>');
    lines.push('    <groupId>com.example</groupId>');
    lines.push(`    <artifactId>${artifactId}</artifactId>`);
    lines.push(`    <version>${this.options.packageVersion}</version>`);
    lines.push('</dependency>');
    lines.push('```');
    lines.push('');

    lines.push('## Usage');
    lines.push('');
    lines.push('```java');
    lines.push(`import ${this.getFormattedPackageName()}.Client;`);
    lines.push('');
    lines.push('Client client = new Client("your-api-key");');
    lines.push('// Use the client...');
    lines.push('```');

    return {
      path: 'README.md',
      content: lines.join('\n'),
    };
  }

  /**
   * Generate examples
   */
  protected override async generateExamples(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const packageName = this.getFormattedPackageName();

    const lines: string[] = [];
    lines.push(`package ${packageName}.examples;`);
    lines.push('');
    lines.push(`import ${packageName}.Client;`);
    lines.push('');
    lines.push('public class BasicExample {');
    lines.push('\tpublic static void main(String[] args) {');
    lines.push('\t\tClient client = new Client("your-api-key");');
    lines.push('\t\t// Use the client...');
    lines.push('\t}');
    lines.push('}');

    files.push({
      path: 'src/main/java/' + packageName.replace(/\./g, '/') + '/examples/BasicExample.java',
      content: lines.join('\n'),
    });

    return files;
  }

  /**
   * Generate tests
   */
  protected override async generateTests(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const packageName = this.getFormattedPackageName();

    const lines: string[] = [];
    lines.push(`package ${packageName};`);
    lines.push('');
    lines.push('import org.junit.jupiter.api.Test;');
    lines.push('import static org.junit.jupiter.api.Assertions.*;');
    lines.push('');
    lines.push('class ClientTest {');
    lines.push('\t@Test');
    lines.push('\tvoid testClientCreation() {');
    lines.push('\t\tClient client = new Client("test-key");');
    lines.push('\t\tassertNotNull(client);');
    lines.push('\t}');
    lines.push('}');

    files.push({
      path: 'src/test/java/' + packageName.replace(/\./g, '/') + '/ClientTest.java',
      content: lines.join('\n'),
    });

    return files;
  }

  /**
   * Convert to UPPER_SNAKE_CASE
   */
  private toUpperSnakeCase(str: string): string {
    return this.toSnakeCase(str).toUpperCase();
  }
}
