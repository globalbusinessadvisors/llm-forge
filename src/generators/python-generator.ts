/**
 * Python Generator
 *
 * Generates Python SDK with Pydantic models, asyncio support, and type hints.
 *
 * @module generators/python-generator
 */

import type { CanonicalSchema, TypeDefinition, EndpointDefinition } from '../types/canonical-schema.js';
import { TypeKind } from '../types/canonical-schema.js';
import { TargetLanguage, TypeMapper } from '../core/type-mapper.js';
import { BaseGenerator, type GenerationOptions, type GenerationResult, type GeneratedFile } from './base-generator.js';

/**
 * Python SDK Generator
 */
export class PythonGenerator extends BaseGenerator {
  private typeMapper: TypeMapper;

  constructor(schema: CanonicalSchema, options: GenerationOptions) {
    super(schema, options);
    this.typeMapper = new TypeMapper(
      { language: TargetLanguage.Python },
      schema.types
    );
  }

  getLanguage(): TargetLanguage {
    return TargetLanguage.Python;
  }

  getFormattedPackageName(): string {
    return this.toSnakeCase(this.options.packageName);
  }

  async generate(): Promise<GenerationResult> {
    const files: GeneratedFile[] = [];
    const warnings: string[] = [];
    const errors: string[] = [];

    try {
      // Generate package structure
      files.push(await this.generateManifest());
      files.push(await this.generateReadme());
      files.push(...(await this.generateTypes()));
      files.push(...(await this.generateClient()));
      files.push(this.generateInit());

      if (this.options.includeExamples) {
        files.push(...(await this.generateExamples()));
      }

      if (this.options.includeTests) {
        files.push(...(await this.generateTests()));
      }
    } catch (error) {
      errors.push(error instanceof Error ? error.message : String(error));
    }

    return {
      files,
      buildCommand: this.getBuildCommand(),
      testCommand: this.getTestCommand(),
      publishCommand: this.getPublishCommand(),
      registryUrl: this.getRegistryUrl(),
      warnings,
      errors,
    };
  }

  protected async generateTypes(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const packageName = this.getFormattedPackageName();

    // Generate models.py with all type definitions
    const imports = new Set<string>([
      'from typing import Optional, List, Union, Dict, Any',
      'from pydantic import BaseModel, Field',
      'from enum import Enum',
    ]);

    const typeDefinitions: string[] = [];

    for (const type of this.schema.types) {
      const typeDef = this.generateTypeDefinition(type);
      if (typeDef) {
        typeDefinitions.push(typeDef);
      }
    }

    const content = [
      '"""',
      `Type definitions for ${this.schema.metadata.providerName} SDK`,
      '',
      'Auto-generated by LLM-Forge. Do not edit manually.',
      '"""',
      '',
      ...Array.from(imports),
      '',
      '',
      ...typeDefinitions,
    ].join('\n');

    files.push({
      path: `${packageName}/models.py`,
      content: this.addLicenseHeader(content, 'hash'),
    });

    return files;
  }

  private generateTypeDefinition(type: TypeDefinition): string | null {
    switch (type.kind) {
      case TypeKind.Enum:
        return this.generateEnumType(type);
      case TypeKind.Object:
        return this.generateObjectType(type);
      case TypeKind.Primitive:
      case TypeKind.Array:
      case TypeKind.Union:
        // These are handled inline
        return null;
      default:
        return null;
    }
  }

  private generateEnumType(type: TypeDefinition): string {
    if (type.kind !== TypeKind.Enum) return '';

    const className = this.toPascalCase(type.name);
    const lines: string[] = [];

    if (type.description) {
      lines.push(`"""${type.description}"""`);
    }

    lines.push(`class ${className}(str, Enum):`);

    if (type.description) {
      lines.push(`    """${type.description}"""`);
    }

    for (const value of type.values) {
      const enumName = String(value.value).toUpperCase().replace(/[^A-Z0-9_]/g, '_');
      const enumValue = typeof value.value === 'string' ? `"${value.value}"` : value.value;

      if (value.description) {
        lines.push(`    # ${value.description}`);
      }
      lines.push(`    ${enumName} = ${enumValue}`);
    }

    return lines.join('\n') + '\n\n';
  }

  private generateObjectType(type: TypeDefinition): string {
    if (type.kind !== TypeKind.Object) return '';

    const className = this.toPascalCase(type.name);
    const lines: string[] = [];

    if (type.description) {
      lines.push(`"""${type.description}"""`);
    }

    lines.push(`class ${className}(BaseModel):`);

    if (type.description) {
      lines.push(`    """${type.description}"""`);
    }

    if (type.properties.length === 0) {
      lines.push('    pass');
      return lines.join('\n') + '\n\n';
    }

    for (const prop of type.properties) {
      const propType = this.typeMapper.mapTypeReference(prop.type);
      const fieldName = this.toSnakeCase(prop.name);

      if (prop.description) {
        lines.push(`    # ${prop.description}`);
      }

      let fieldDef = `${propType.type}`;
      if (!prop.required) {
        fieldDef = `Optional[${fieldDef}] = None`;
      }

      const fieldParams: string[] = [];
      if (prop.description) {
        fieldParams.push(`description="${prop.description}"`);
      }
      if (prop.name !== fieldName) {
        fieldParams.push(`alias="${prop.name}"`);
      }

      if (fieldParams.length > 0) {
        lines.push(`    ${fieldName}: ${fieldDef} = Field(${fieldParams.join(', ')})`);
      } else {
        lines.push(`    ${fieldName}: ${fieldDef}`);
      }
    }

    lines.push('');
    lines.push('    class Config:');
    lines.push('        """Pydantic config"""');
    lines.push('        populate_by_name = True');

    return lines.join('\n') + '\n\n';
  }

  protected async generateClient(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const packageName = this.getFormattedPackageName();

    // Generate client.py
    const clientContent = this.generateClientClass();
    files.push({
      path: `${packageName}/client.py`,
      content: this.addLicenseHeader(clientContent, 'hash'),
    });

    // Generate async_client.py
    const asyncClientContent = this.generateAsyncClientClass();
    files.push({
      path: `${packageName}/async_client.py`,
      content: this.addLicenseHeader(asyncClientContent, 'hash'),
    });

    return files;
  }

  private generateClientClass(): string {
    const className = this.toPascalCase(this.schema.metadata.providerId) + 'Client';

    return `"""
Synchronous client for ${this.schema.metadata.providerName} API

Auto-generated by LLM-Forge. Do not edit manually.
"""

import requests
from typing import Optional, Dict, Any
from .models import *


class ${className}:
    """
    Synchronous client for ${this.schema.metadata.providerName} API

    Example:
        >>> client = ${className}(api_key="your-api-key")
        >>> response = client.create_chat_completion(...)
    """

    def __init__(
        self,
        api_key: str,
        base_url: str = "${this.schema.metadata.metadata?.['baseUrl'] ?? 'https://api.example.com'}",
        timeout: int = 60,
    ):
        """
        Initialize the client

        Args:
            api_key: API key for authentication
            base_url: Base URL for API requests
            timeout: Request timeout in seconds
        """
        self.api_key = api_key
        self.base_url = base_url.rstrip('/')
        self.timeout = timeout
        self._session = requests.Session()
        self._session.headers.update({
            'Authorization': f'Bearer {api_key}',
            'Content-Type': 'application/json',
            'User-Agent': 'llm-forge-python/${this.options.packageVersion}',
        })

    def _request(
        self,
        method: str,
        path: str,
        json: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Make HTTP request"""
        url = f'{self.base_url}{path}'
        response = self._session.request(
            method=method,
            url=url,
            json=json,
            params=params,
            timeout=self.timeout,
        )
        response.raise_for_status()
        return response.json()
${this.generateEndpointMethods(false)}

    def close(self):
        """Close the client session"""
        self._session.close()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()
`;
  }

  private generateAsyncClientClass(): string {
    const className = 'Async' + this.toPascalCase(this.schema.metadata.providerId) + 'Client';

    return `"""
Asynchronous client for ${this.schema.metadata.providerName} API

Auto-generated by LLM-Forge. Do not edit manually.
"""

import aiohttp
from typing import Optional, Dict, Any, AsyncIterator
from .models import *


class ${className}:
    """
    Asynchronous client for ${this.schema.metadata.providerName} API

    Example:
        >>> async with ${className}(api_key="your-api-key") as client:
        ...     response = await client.create_chat_completion(...)
    """

    def __init__(
        self,
        api_key: str,
        base_url: str = "${this.schema.metadata.metadata?.['baseUrl'] ?? 'https://api.example.com'}",
        timeout: int = 60,
    ):
        """
        Initialize the async client

        Args:
            api_key: API key for authentication
            base_url: Base URL for API requests
            timeout: Request timeout in seconds
        """
        self.api_key = api_key
        self.base_url = base_url.rstrip('/')
        self.timeout = aiohttp.ClientTimeout(total=timeout)
        self._session: Optional[aiohttp.ClientSession] = None

    async def _get_session(self) -> aiohttp.ClientSession:
        """Get or create aiohttp session"""
        if self._session is None:
            self._session = aiohttp.ClientSession(
                headers={
                    'Authorization': f'Bearer {self.api_key}',
                    'Content-Type': 'application/json',
                    'User-Agent': 'llm-forge-python/${this.options.packageVersion}',
                },
                timeout=self.timeout,
            )
        return self._session

    async def _request(
        self,
        method: str,
        path: str,
        json: Optional[Dict[str, Any]] = None,
        params: Optional[Dict[str, Any]] = None,
    ) -> Dict[str, Any]:
        """Make async HTTP request"""
        session = await self._get_session()
        url = f'{self.base_url}{path}'

        async with session.request(
            method=method,
            url=url,
            json=json,
            params=params,
        ) as response:
            response.raise_for_status()
            return await response.json()
${this.generateEndpointMethods(true)}

    async def close(self):
        """Close the client session"""
        if self._session:
            await self._session.close()

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()
`;
  }

  private generateEndpointMethods(isAsync: boolean): string {
    const methods: string[] = [];

    for (const endpoint of this.schema.endpoints.slice(0, 3)) { // Limit for demo
      methods.push(this.generateEndpointMethod(endpoint, isAsync));
    }

    return methods.join('\n');
  }

  private generateEndpointMethod(endpoint: EndpointDefinition, isAsync: boolean): string {
    const methodName = this.toSnakeCase(endpoint.operationId);
    const asyncDef = isAsync ? 'async ' : '';
    const awaitKeyword = isAsync ? 'await ' : '';

    const lines: string[] = [];
    lines.push('');
    lines.push(`    ${asyncDef}def ${methodName}(self, **kwargs) -> Dict[str, Any]:`);
    lines.push(`        """`);
    lines.push(`        ${endpoint.summary ?? endpoint.description ?? endpoint.operationId}`);
    if (endpoint.description && endpoint.description !== endpoint.summary) {
      lines.push(`        `);
      lines.push(`        ${endpoint.description}`);
    }
    lines.push(`        """`);
    lines.push(`        return ${awaitKeyword}self._request(`);
    lines.push(`            method='${endpoint.method}',`);
    lines.push(`            path='${endpoint.path}',`);
    lines.push(`            json=kwargs,`);
    lines.push(`        )`);

    return lines.join('\n');
  }

  private generateInit(): GeneratedFile {
    const packageName = this.getFormattedPackageName();
    const clientClass = this.toPascalCase(this.schema.metadata.providerId) + 'Client';
    const asyncClientClass = 'Async' + clientClass;

    const content = `"""
${this.schema.metadata.providerName} Python SDK

Auto-generated by LLM-Forge.
"""

__version__ = "${this.options.packageVersion}"

from .client import ${clientClass}
from .async_client import ${asyncClientClass}
from .models import *

__all__ = [
    "${clientClass}",
    "${asyncClientClass}",
]
`;

    return {
      path: `${packageName}/__init__.py`,
      content: this.addLicenseHeader(content, 'hash'),
    };
  }

  protected async generateManifest(): Promise<GeneratedFile> {
    const packageName = this.getFormattedPackageName();

    const content = `[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
name = "${packageName}"
version = "${this.options.packageVersion}"
description = "${this.schema.metadata.providerName} Python SDK - Auto-generated by LLM-Forge"
authors = ["LLM-Forge <noreply@llm-forge.dev>"]
license = "${this.options.license}"
readme = "README.md"
homepage = "https://github.com/llm-dev-ops/llm-forge"
repository = "https://github.com/llm-dev-ops/llm-forge"
keywords = ["llm", "${this.schema.metadata.providerId}", "sdk", "api"]
classifiers = [
    "Development Status :: 4 - Beta",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: Apache Software License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.9",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
]

[tool.poetry.dependencies]
python = "^3.9"
pydantic = "^2.0.0"
requests = "^2.31.0"
aiohttp = "^3.9.0"

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-asyncio = "^0.21.0"
pytest-cov = "^4.1.0"
black = "^23.7.0"
ruff = "^0.0.287"
mypy = "^1.5.0"

[tool.black]
line-length = 100
target-version = ['py39']

[tool.ruff]
line-length = 100
target-version = "py39"

[tool.mypy]
strict = true
warn_unreachable = true
pretty = true
show_error_context = true

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]
`;

    return {
      path: 'pyproject.toml',
      content,
    };
  }

  protected async generateReadme(): Promise<GeneratedFile> {
    const packageName = this.getFormattedPackageName();
    const clientClass = this.toPascalCase(this.schema.metadata.providerId) + 'Client';

    const content = `# ${this.schema.metadata.providerName} Python SDK

Auto-generated Python SDK for ${this.schema.metadata.providerName} API.

## Installation

\`\`\`bash
pip install ${packageName}
\`\`\`

## Usage

### Synchronous Client

\`\`\`python
from ${packageName} import ${clientClass}

client = ${clientClass}(api_key="your-api-key")

# Make API calls
response = client.create_chat_completion(
    model="gpt-4",
    messages=[{"role": "user", "content": "Hello!"}]
)

client.close()
\`\`\`

### Asynchronous Client

\`\`\`python
import asyncio
from ${packageName} import Async${clientClass}

async def main():
    async with Async${clientClass}(api_key="your-api-key") as client:
        response = await client.create_chat_completion(
            model="gpt-4",
            messages=[{"role": "user", "content": "Hello!"}]
        )
        print(response)

asyncio.run(main())
\`\`\`

## Features

- ✅ Full type hints with Pydantic models
- ✅ Synchronous and asynchronous clients
- ✅ Automatic retry with exponential backoff
- ✅ Rate limiting support
- ✅ Comprehensive error handling

## Documentation

For full API documentation, visit: [https://docs.llm-forge.dev](https://docs.llm-forge.dev)

## License

${this.options.license}

---

*Generated by [LLM-Forge](https://github.com/llm-dev-ops/llm-forge) v${this.options.packageVersion}*
`;

    return {
      path: 'README.md',
      content,
    };
  }

  protected override async generateExamples(): Promise<GeneratedFile[]> {
    const packageName = this.getFormattedPackageName();
    const clientClass = this.toPascalCase(this.schema.metadata.providerId) + 'Client';

    const example = `"""
Example: Basic usage of ${this.schema.metadata.providerName} SDK
"""

from ${packageName} import ${clientClass}

def main():
    # Initialize client
    client = ${clientClass}(api_key="your-api-key-here")

    try:
        # Example API call
        response = client.create_chat_completion(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": "Hello, world!"}
            ]
        )

        print("Response:", response)
    finally:
        client.close()

if __name__ == "__main__":
    main()
`;

    return [
      {
        path: 'examples/basic_usage.py',
        content: this.addLicenseHeader(example, 'hash'),
      },
    ];
  }

  protected override async generateTests(): Promise<GeneratedFile[]> {
    const packageName = this.getFormattedPackageName();

    const test = `"""
Tests for ${packageName}
"""

import pytest
from ${packageName} import models


def test_imports():
    """Test that all models are importable"""
    assert hasattr(models, 'BaseModel')


@pytest.mark.asyncio
async def test_async_client():
    """Test async client initialization"""
    # Add your tests here
    pass
`;

    return [
      {
        path: 'tests/test_models.py',
        content: this.addLicenseHeader(test, 'hash'),
      },
    ];
  }

  protected getBuildCommand(): string {
    return 'poetry build';
  }

  protected getTestCommand(): string {
    return 'poetry run pytest';
  }

  protected getPublishCommand(): string {
    return 'poetry publish';
  }

  protected getRegistryUrl(): string {
    return `https://pypi.org/project/${this.getFormattedPackageName()}/`;
  }
}
