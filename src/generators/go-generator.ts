/**
 * Go SDK Generator
 *
 * Generates production-ready Go SDKs with:
 * - Structs with JSON tags
 * - Native net/http client
 * - goroutines for concurrency
 * - Go modules
 * - Full type safety
 *
 * @module generators/go-generator
 */

import type { CanonicalSchema, TypeDefinition, EndpointDefinition } from '../types/canonical-schema.js';
import { TypeKind } from '../types/canonical-schema.js';
import { BaseGenerator, type GenerationOptions, type GenerationResult, type GeneratedFile } from './base-generator.js';
import { TypeMapper, TargetLanguage } from '../core/type-mapper.js';

/**
 * Go SDK Generator
 */
export class GoGenerator extends BaseGenerator {
  private typeMapper: TypeMapper;

  constructor(schema: CanonicalSchema, options: GenerationOptions) {
    super(schema, options);
    this.typeMapper = new TypeMapper(
      { language: TargetLanguage.Go },
      schema.types
    );
  }

  override getLanguage(): TargetLanguage {
    return TargetLanguage.Go;
  }

  getFormattedPackageName(): string {
    return this.toSnakeCase(this.options.packageName).replace(/-/g, '');
  }

  protected getBuildCommand(): string {
    return 'go build';
  }

  protected getTestCommand(): string {
    return 'go test ./...';
  }

  protected getPublishCommand(): string {
    return 'git tag v' + this.options.packageVersion + ' && git push origin v' + this.options.packageVersion;
  }

  protected getRegistryUrl(): string {
    return 'https://pkg.go.dev';
  }

  /**
   * Generate complete Go SDK
   */
  async generate(): Promise<GenerationResult> {
    const files: GeneratedFile[] = [];
    const warnings: string[] = [];
    const errors: string[] = [];

    try {
      // Generate types
      files.push(...(await this.generateTypes()));

      // Generate client
      files.push(...(await this.generateClient()));

      // Generate go.mod
      files.push(await this.generateManifest());

      // Generate README
      files.push(await this.generateReadme());

      // Generate examples
      if (this.options.includeExamples) {
        files.push(...(await this.generateExamples()));
      }

      // Generate tests
      if (this.options.includeTests) {
        files.push(...(await this.generateTests()));
      }
    } catch (error) {
      errors.push(error instanceof Error ? error.message : String(error));
    }

    return {
      files,
      warnings,
      errors,
      buildCommand: this.getBuildCommand(),
      testCommand: this.getTestCommand(),
      publishCommand: this.getPublishCommand(),
      registryUrl: this.getRegistryUrl(),
    };
  }

  /**
   * Generate type definitions
   */
  protected async generateTypes(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];

    const typesContent = this.generateTypesFile();
    files.push({
      path: 'types.go',
      content: typesContent,
    });

    return files;
  }

  /**
   * Generate types.go
   */
  private generateTypesFile(): string {
    const lines: string[] = [];
    const packageName = this.getFormattedPackageName();

    lines.push(`package ${packageName}`);
    lines.push('');
    lines.push('// Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push('');

    // Check if we need time package
    const needsTime = this.schema.types.some(t => {
      if (t.kind === TypeKind.Object && t.properties) {
        return t.properties.some(p => {
          const mapped = this.typeMapper.mapTypeReference(p.type);
          return mapped.type.includes('time.Time');
        });
      }
      return false;
    });

    if (needsTime) {
      lines.push('import "time"');
      lines.push('');
    }

    // Generate each type
    for (const type of this.schema.types) {
      const typeCode = this.generateType(type);
      if (typeCode) {
        lines.push(typeCode);
        lines.push('');
      }
    }

    return lines.join('\n');
  }

  /**
   * Generate a single type definition
   */
  private generateType(type: TypeDefinition): string {
    switch (type.kind) {
      case TypeKind.Object:
        return this.generateStruct(type);
      case TypeKind.Enum:
        return this.generateEnum(type);
      default:
        return '';
    }
  }

  /**
   * Generate struct
   */
  private generateStruct(type: TypeDefinition): string {
    const lines: string[] = [];

    // Add documentation
    if (type.description) {
      lines.push(`// ${this.toPascalCase(type.name)} ${type.description}`);
    } else {
      lines.push(`// ${this.toPascalCase(type.name)} type definition`);
    }

    // Struct declaration
    lines.push(`type ${this.toPascalCase(type.name)} struct {`);

    // Properties
    if (type.kind === TypeKind.Object && type.properties) {
      for (const prop of type.properties) {
        const mappedType = this.typeMapper.mapTypeReference(prop.type);

        // Property documentation
        if (prop.description) {
          lines.push(`\t// ${prop.description}`);
        }

        // Handle optional fields with pointer
        const isOptional = !prop.required;
        let fieldType = mappedType.type;

        // Make optional fields pointers (except slices and maps which are already reference types)
        if (isOptional && !fieldType.startsWith('[]') && !fieldType.startsWith('map[')) {
          if (!fieldType.startsWith('*')) {
            fieldType = '*' + fieldType;
          }
        }

        const fieldName = this.toPascalCase(prop.name);
        const jsonTag = prop.name;
        const omitEmpty = isOptional ? ',omitempty' : '';

        lines.push(`\t${fieldName} ${fieldType} \`json:"${jsonTag}${omitEmpty}"\``);
      }
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate enum (as string constants)
   */
  private generateEnum(type: TypeDefinition): string {
    const lines: string[] = [];
    const typeName = this.toPascalCase(type.name);

    // Add documentation
    if (type.description) {
      lines.push(`// ${typeName} ${type.description}`);
    }

    // Type alias
    lines.push(`type ${typeName} string`);
    lines.push('');

    // Constants
    lines.push('const (');
    if (type.kind === TypeKind.Enum && type.values) {
      for (const value of type.values) {
        const constName = `${typeName}${this.toPascalCase(String(value.value))}`;
        if (value.description) {
          lines.push(`\t// ${constName} ${value.description}`);
        }
        lines.push(`\t${constName} ${typeName} = "${value.value}"`);
      }
    }
    lines.push(')');

    return lines.join('\n');
  }

  /**
   * Generate HTTP client
   */
  protected async generateClient(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];

    const clientContent = this.generateClientFile();
    files.push({
      path: 'client.go',
      content: clientContent,
    });

    return files;
  }

  /**
   * Generate client.go
   */
  private generateClientFile(): string {
    const lines: string[] = [];
    const packageName = this.getFormattedPackageName();

    lines.push(`package ${packageName}`);
    lines.push('');
    lines.push('// Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push('');
    lines.push('import (');
    lines.push('\t"bytes"');
    lines.push('\t"context"');
    lines.push('\t"encoding/json"');
    lines.push('\t"fmt"');
    lines.push('\t"io"');
    lines.push('\t"net/http"');
    lines.push('\t"time"');
    lines.push(')');
    lines.push('');

    // Config struct
    lines.push('// Config holds the client configuration');
    lines.push('type Config struct {');
    lines.push('\tAPIKey  string');
    lines.push('\tBaseURL string');
    lines.push('\tTimeout time.Duration');
    lines.push('}');
    lines.push('');

    // DefaultConfig
    lines.push('// DefaultConfig returns default configuration');
    lines.push('func DefaultConfig() *Config {');
    lines.push('\treturn &Config{');
    lines.push('\t\tBaseURL: "https://api.example.com",');
    lines.push('\t\tTimeout: 60 * time.Second,');
    lines.push('\t}');
    lines.push('}');
    lines.push('');

    // Client struct
    lines.push('// Client is the API client');
    lines.push('type Client struct {');
    lines.push('\tconfig     *Config');
    lines.push('\thttpClient *http.Client');
    lines.push('}');
    lines.push('');

    // NewClient
    lines.push('// NewClient creates a new API client');
    lines.push('func NewClient(apiKey string) *Client {');
    lines.push('\tconfig := DefaultConfig()');
    lines.push('\tconfig.APIKey = apiKey');
    lines.push('\treturn NewClientWithConfig(config)');
    lines.push('}');
    lines.push('');

    // NewClientWithConfig
    lines.push('// NewClientWithConfig creates a new client with custom config');
    lines.push('func NewClientWithConfig(config *Config) *Client {');
    lines.push('\treturn &Client{');
    lines.push('\t\tconfig: config,');
    lines.push('\t\thttpClient: &http.Client{');
    lines.push('\t\t\tTimeout: config.Timeout,');
    lines.push('\t\t},');
    lines.push('\t}');
    lines.push('}');
    lines.push('');

    // Generate endpoint methods
    for (const endpoint of this.schema.endpoints) {
      lines.push(this.generateEndpointMethod(endpoint));
      lines.push('');
    }

    // Helper request method
    lines.push('// request makes an HTTP request');
    lines.push('func (c *Client) request(ctx context.Context, method, path string, body interface{}, result interface{}) error {');
    lines.push('\turl := c.config.BaseURL + path');
    lines.push('');
    lines.push('\tvar reqBody io.Reader');
    lines.push('\tif body != nil {');
    lines.push('\t\tdata, err := json.Marshal(body)');
    lines.push('\t\tif err != nil {');
    lines.push('\t\t\treturn fmt.Errorf("failed to marshal request: %w", err)');
    lines.push('\t\t}');
    lines.push('\t\treqBody = bytes.NewReader(data)');
    lines.push('\t}');
    lines.push('');
    lines.push('\treq, err := http.NewRequestWithContext(ctx, method, url, reqBody)');
    lines.push('\tif err != nil {');
    lines.push('\t\treturn fmt.Errorf("failed to create request: %w", err)');
    lines.push('\t}');
    lines.push('');
    lines.push('\treq.Header.Set("Authorization", "Bearer "+c.config.APIKey)');
    lines.push('\treq.Header.Set("Content-Type", "application/json")');
    lines.push('');
    lines.push('\tresp, err := c.httpClient.Do(req)');
    lines.push('\tif err != nil {');
    lines.push('\t\treturn fmt.Errorf("request failed: %w", err)');
    lines.push('\t}');
    lines.push('\tdefer resp.Body.Close()');
    lines.push('');
    lines.push('\tif resp.StatusCode < 200 || resp.StatusCode >= 300 {');
    lines.push('\t\tbody, _ := io.ReadAll(resp.Body)');
    lines.push('\t\treturn fmt.Errorf("API error (%d): %s", resp.StatusCode, string(body))');
    lines.push('\t}');
    lines.push('');
    lines.push('\tif result != nil {');
    lines.push('\t\tif err := json.NewDecoder(resp.Body).Decode(result); err != nil {');
    lines.push('\t\t\treturn fmt.Errorf("failed to decode response: %w", err)');
    lines.push('\t\t}');
    lines.push('\t}');
    lines.push('');
    lines.push('\treturn nil');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate endpoint method
   */
  private generateEndpointMethod(endpoint: EndpointDefinition): string {
    const lines: string[] = [];

    // Documentation
    const methodName = this.toPascalCase(endpoint.operationId);
    if (endpoint.description) {
      lines.push(`// ${methodName} ${endpoint.description}`);
    }

    // Method signature
    lines.push(`func (c *Client) ${methodName}(ctx context.Context`);

    // Parameters
    if (endpoint.requestBody) {
      const bodyType = this.typeMapper.mapTypeReference(endpoint.requestBody.type);
      lines[lines.length - 1] += `, request *${bodyType.type}`;
    }

    // Return type
    const responseType = endpoint.responses.find(r => r.statusCode === 200);
    const returnType = responseType?.type
      ? this.typeMapper.mapTypeReference(responseType.type).type
      : 'interface{}';

    lines[lines.length - 1] += `) (*${returnType}, error) {`;

    // Method body
    lines.push(`\tvar result ${returnType}`);
    const httpMethod = endpoint.method.toUpperCase();
    const path = endpoint.path;

    if (endpoint.requestBody) {
      lines.push(`\terr := c.request(ctx, "${httpMethod}", "${path}", request, &result)`);
    } else {
      lines.push(`\terr := c.request(ctx, "${httpMethod}", "${path}", nil, &result)`);
    }

    lines.push('\tif err != nil {');
    lines.push('\t\treturn nil, err');
    lines.push('\t}');
    lines.push('\treturn &result, nil');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate go.mod
   */
  protected async generateManifest(): Promise<GeneratedFile> {
    const packageName = this.getFormattedPackageName();
    const lines: string[] = [];

    lines.push(`module github.com/yourorg/${packageName}`);
    lines.push('');
    lines.push('go 1.21');

    return {
      path: 'go.mod',
      content: lines.join('\n'),
    };
  }

  /**
   * Generate README
   */
  protected async generateReadme(): Promise<GeneratedFile> {
    const packageName = this.getFormattedPackageName();
    const lines: string[] = [];

    lines.push(`# ${this.schema.metadata.providerName} Go SDK`);
    lines.push('');
    if (this.schema.metadata.metadata?.['description']) {
      lines.push(String(this.schema.metadata.metadata['description']));
      lines.push('');
    }
    lines.push('Auto-generated by LLM-Forge.');
    lines.push('');

    lines.push('## Installation');
    lines.push('');
    lines.push('```bash');
    lines.push(`go get github.com/yourorg/${packageName}`);
    lines.push('```');
    lines.push('');

    lines.push('## Usage');
    lines.push('');
    lines.push('```go');
    lines.push('package main');
    lines.push('');
    lines.push('import (');
    lines.push('\t"context"');
    lines.push(`\t"github.com/yourorg/${packageName}"`);
    lines.push(')');
    lines.push('');
    lines.push('func main() {');
    lines.push(`\tclient := ${packageName}.NewClient("your-api-key")`);
    lines.push('\t// Use the client...');
    lines.push('}');
    lines.push('```');

    return {
      path: 'README.md',
      content: lines.join('\n'),
    };
  }

  /**
   * Generate examples
   */
  protected override async generateExamples(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const packageName = this.getFormattedPackageName();

    const lines: string[] = [];
    lines.push('package main');
    lines.push('');
    lines.push('import (');
    lines.push('\t"context"');
    lines.push('\t"fmt"');
    lines.push(`\t"github.com/yourorg/${packageName}"`);
    lines.push(')');
    lines.push('');
    lines.push('func main() {');
    lines.push(`\tclient := ${packageName}.NewClient("your-api-key")`);
    lines.push('\tctx := context.Background()');
    lines.push('');
    lines.push('\t// Example API call');
    lines.push('\t// response, err := client.SomeMethod(ctx, &request)');
    lines.push('\t// if err != nil {');
    lines.push('\t//     panic(err)');
    lines.push('\t// }');
    lines.push('\t// fmt.Printf("Response: %+v\\n", response)');
    lines.push('}');

    files.push({
      path: 'examples/basic/main.go',
      content: lines.join('\n'),
    });

    return files;
  }

  /**
   * Generate tests
   */
  protected override async generateTests(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const packageName = this.getFormattedPackageName();

    const lines: string[] = [];
    lines.push(`package ${packageName}_test`);
    lines.push('');
    lines.push('import (');
    lines.push('\t"testing"');
    lines.push(`\t"github.com/yourorg/${packageName}"`);
    lines.push(')');
    lines.push('');
    lines.push('func TestClientCreation(t *testing.T) {');
    lines.push(`\tclient := ${packageName}.NewClient("test-key")`);
    lines.push('\tif client == nil {');
    lines.push('\t\tt.Fatal("client should not be nil")');
    lines.push('\t}');
    lines.push('}');

    files.push({
      path: 'client_test.go',
      content: lines.join('\n'),
    });

    return files;
  }
}
