/**
 * Rust SDK Generator
 *
 * Generates production-ready Rust SDKs with:
 * - Serde structs for type definitions
 * - tokio async runtime
 * - reqwest HTTP client
 * - Cargo package management
 * - Full type safety
 *
 * @module generators/rust-generator
 */

import type { CanonicalSchema, TypeDefinition, EndpointDefinition } from '../types/canonical-schema.js';
import { TypeKind } from '../types/canonical-schema.js';
import { BaseGenerator, type GenerationOptions, type GenerationResult, type GeneratedFile } from './base-generator.js';
import { TypeMapper, TargetLanguage } from '../core/type-mapper.js';

/**
 * Rust SDK Generator
 */
export class RustGenerator extends BaseGenerator {
  private typeMapper: TypeMapper;

  constructor(schema: CanonicalSchema, options: GenerationOptions) {
    super(schema, options);
    this.typeMapper = new TypeMapper(
      { language: TargetLanguage.Rust },
      schema.types
    );
  }

  override getLanguage(): TargetLanguage {
    return TargetLanguage.Rust;
  }

  getFormattedPackageName(): string {
    return this.toSnakeCase(this.options.packageName);
  }

  protected getBuildCommand(): string {
    return 'cargo build --release';
  }

  protected getTestCommand(): string {
    return 'cargo test';
  }

  protected getPublishCommand(): string {
    return 'cargo publish';
  }

  protected getRegistryUrl(): string {
    return 'https://crates.io';
  }

  /**
   * Generate complete Rust SDK
   */
  async generate(): Promise<GenerationResult> {
    const files: GeneratedFile[] = [];
    const warnings: string[] = [];
    const errors: string[] = [];

    try {
      // Generate types (lib.rs with models module)
      files.push(...(await this.generateTypes()));

      // Generate client
      files.push(...(await this.generateClient()));

      // Generate Cargo.toml
      files.push(await this.generateManifest());

      // Generate README
      files.push(await this.generateReadme());

      // Generate examples
      if (this.options.includeExamples) {
        files.push(...(await this.generateExamples()));
      }

      // Generate tests
      if (this.options.includeTests) {
        files.push(...(await this.generateTests()));
      }
    } catch (error) {
      errors.push(error instanceof Error ? error.message : String(error));
    }

    return {
      files,
      warnings,
      errors,
      buildCommand: this.getBuildCommand(),
      testCommand: this.getTestCommand(),
      publishCommand: this.getPublishCommand(),
      registryUrl: this.getRegistryUrl(),
    };
  }

  /**
   * Generate type definitions
   */
  override async generateTypes(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];

    // Generate lib.rs (main entry point)
    const libContent = this.generateLibRs();
    files.push({
      path: 'src/lib.rs',
      content: libContent,
    });

    // Generate models.rs (type definitions)
    const modelsContent = this.generateModels();
    files.push({
      path: 'src/models.rs',
      content: modelsContent,
    });

    return files;
  }

  /**
   * Generate lib.rs
   */
  private generateLibRs(): string {
    const lines: string[] = [];

    lines.push('//! ' + (this.schema.metadata.metadata?.['title'] || 'LLM SDK'));
    lines.push('//!');
    if (this.schema.metadata.metadata?.['description']) {
      lines.push('//! ' + this.schema.metadata.metadata['description']);
      lines.push('//!');
    }
    lines.push('//! Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push('');
    lines.push('pub mod models;');
    lines.push('pub mod client;');
    lines.push('pub mod error;');
    lines.push('');
    lines.push('pub use client::Client;');
    lines.push('pub use error::{Error, Result};');
    lines.push('pub use models::*;');
    lines.push('');

    return lines.join('\n');
  }

  /**
   * Generate models.rs
   */
  private generateModels(): string {
    const lines: string[] = [];

    lines.push('//! Type definitions');
    lines.push('//!');
    lines.push('//! Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push('');
    lines.push('use serde::{Deserialize, Serialize};');
    lines.push('');

    // Generate each type
    for (const type of this.schema.types) {
      lines.push(this.generateType(type));
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Generate a single type definition
   */
  private generateType(type: TypeDefinition): string {
    switch (type.kind) {
      case TypeKind.Object:
        return this.generateStruct(type);
      case TypeKind.Enum:
        return this.generateEnum(type);
      case TypeKind.Array:
      case TypeKind.Union:
      case TypeKind.Primitive:
        // These are handled inline
        return '';
      default:
        return '';
    }
  }

  /**
   * Generate struct
   */
  private generateStruct(type: TypeDefinition): string {
    const lines: string[] = [];

    // Add documentation
    if (type.description) {
      lines.push(`/// ${type.description}`);
    }

    // Add derive attributes
    lines.push('#[derive(Debug, Clone, Serialize, Deserialize)]');
    lines.push('#[serde(rename_all = "snake_case")]');

    // Struct declaration
    lines.push(`pub struct ${this.toPascalCase(type.name)} {`);

    // Properties
    if (type.kind === TypeKind.Object && type.properties) {
      for (const prop of type.properties) {
        const mappedType = this.typeMapper.mapTypeReference(prop.type);

        // Property documentation
        if (prop.description) {
          lines.push(`    /// ${prop.description}`);
        }

        // Handle optional fields
        const isOptional = !prop.required;
        const fieldType = isOptional && !mappedType.type.startsWith('Option<')
          ? `Option<${mappedType.type}>`
          : mappedType.type;

        // Add serde attributes for optional fields
        if (isOptional) {
          lines.push('    #[serde(skip_serializing_if = "Option::is_none")]');
        }

        lines.push(`    pub ${this.toSnakeCase(prop.name)}: ${fieldType},`);
      }
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate enum
   */
  private generateEnum(type: TypeDefinition): string {
    const lines: string[] = [];

    // Add documentation
    if (type.description) {
      lines.push(`/// ${type.description}`);
    }

    // Add derive attributes
    lines.push('#[derive(Debug, Clone, Serialize, Deserialize)]');
    lines.push('#[serde(rename_all = "snake_case")]');

    // Enum declaration
    lines.push(`pub enum ${this.toPascalCase(type.name)} {`);

    // Values
    if (type.kind === TypeKind.Enum && type.values) {
      for (const value of type.values) {
        if (value.description) {
          lines.push(`    /// ${value.description}`);
        }

        // Rust enum variants are PascalCase
        const variantName = this.toPascalCase(String(value.value));
        lines.push(`    #[serde(rename = "${value.value}")]`);
        lines.push(`    ${variantName},`);
      }
    }

    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate HTTP client
   */
  override async generateClient(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];

    // Generate client.rs
    const clientContent = this.generateClientRs();
    files.push({
      path: 'src/client.rs',
      content: clientContent,
    });

    // Generate error.rs
    const errorContent = this.generateErrorRs();
    files.push({
      path: 'src/error.rs',
      content: errorContent,
    });

    return files;
  }

  /**
   * Generate client.rs
   */
  private generateClientRs(): string {
    const lines: string[] = [];

    lines.push('//! HTTP client');
    lines.push('//!');
    lines.push('//! Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push('');
    lines.push('use reqwest::{Client as HttpClient, Method, RequestBuilder};');
    lines.push('use serde::Serialize;');
    lines.push('use serde::de::DeserializeOwned;');
    lines.push('');
    lines.push('use crate::error::{Error, Result};');
    lines.push('use crate::models::*;');
    lines.push('');

    // Client configuration struct
    lines.push('/// Client configuration');
    lines.push('#[derive(Debug, Clone)]');
    lines.push('pub struct Config {');
    lines.push('    /// API key');
    lines.push('    pub api_key: String,');
    lines.push('    /// Base URL');
    lines.push('    pub base_url: String,');
    lines.push('    /// Request timeout in seconds');
    lines.push('    pub timeout: u64,');
    lines.push('}');
    lines.push('');

    lines.push('impl Default for Config {');
    lines.push('    fn default() -> Self {');
    lines.push('        Self {');
    lines.push('            api_key: String::new(),');
    lines.push('            base_url: "https://api.example.com".to_string(),');
    lines.push('            timeout: 60,');
    lines.push('        }');
    lines.push('    }');
    lines.push('}');
    lines.push('');

    // Client struct
    lines.push('/// API Client');
    lines.push('#[derive(Debug, Clone)]');
    lines.push('pub struct Client {');
    lines.push('    config: Config,');
    lines.push('    http_client: HttpClient,');
    lines.push('}');
    lines.push('');

    lines.push('impl Client {');
    lines.push('    /// Create a new client with the given API key');
    lines.push('    pub fn new(api_key: impl Into<String>) -> Self {');
    lines.push('        let mut config = Config::default();');
    lines.push('        config.api_key = api_key.into();');
    lines.push('        Self::with_config(config)');
    lines.push('    }');
    lines.push('');

    lines.push('    /// Create a new client with custom configuration');
    lines.push('    pub fn with_config(config: Config) -> Self {');
    lines.push('        let http_client = HttpClient::builder()');
    lines.push('            .timeout(std::time::Duration::from_secs(config.timeout))');
    lines.push('            .build()');
    lines.push('            .expect("Failed to create HTTP client");');
    lines.push('');
    lines.push('        Self { config, http_client }');
    lines.push('    }');
    lines.push('');

    // Generate endpoint methods
    for (const endpoint of this.schema.endpoints) {
      lines.push(this.generateEndpointMethod(endpoint));
      lines.push('');
    }

    // Helper request method
    lines.push('    /// Make an HTTP request');
    lines.push('    async fn request<T: DeserializeOwned>(');
    lines.push('        &self,');
    lines.push('        method: Method,');
    lines.push('        path: &str,');
    lines.push('        body: Option<&impl Serialize>,');
    lines.push('    ) -> Result<T> {');
    lines.push('        let url = format!("{}{}", self.config.base_url, path);');
    lines.push('');
    lines.push('        let mut request = self.http_client.request(method, &url)');
    lines.push('            .header("Authorization", format!("Bearer {}", self.config.api_key))');
    lines.push('            .header("Content-Type", "application/json");');
    lines.push('');
    lines.push('        if let Some(body) = body {');
    lines.push('            request = request.json(body);');
    lines.push('        }');
    lines.push('');
    lines.push('        let response = request.send().await?;');
    lines.push('');
    lines.push('        if !response.status().is_success() {');
    lines.push('            let status = response.status();');
    lines.push('            let text = response.text().await?;');
    lines.push('            return Err(Error::ApiError {');
    lines.push('                status: status.as_u16(),');
    lines.push('                message: text,');
    lines.push('            });');
    lines.push('        }');
    lines.push('');
    lines.push('        Ok(response.json().await?)');
    lines.push('    }');
    lines.push('}');

    return lines.join('\n');
  }

  /**
   * Generate endpoint method
   */
  private generateEndpointMethod(endpoint: EndpointDefinition): string {
    const lines: string[] = [];

    // Documentation
    if (endpoint.description) {
      lines.push(`    /// ${endpoint.description}`);
    }

    // Method signature
    const methodName = this.toSnakeCase(endpoint.operationId);
    lines.push(`    pub async fn ${methodName}(`);
    lines.push('        &self,');

    // Parameters
    if (endpoint.requestBody) {
      const bodyType = this.typeMapper.mapTypeReference(endpoint.requestBody.type);
      lines.push(`        request: &${bodyType.type},`);
    }

    // Return type
    const responseType = endpoint.responses.find(r => r.statusCode === 200);
    const returnType = responseType?.type
      ? this.typeMapper.mapTypeReference(responseType.type).type
      : 'serde_json::Value';

    lines.push(`    ) -> Result<${returnType}> {`);

    // Method body
    const httpMethod = endpoint.method.toUpperCase();
    const path = endpoint.path;

    if (endpoint.requestBody) {
      lines.push(`        self.request(Method::${httpMethod}, "${path}", Some(request)).await`);
    } else {
      lines.push(`        self.request::<${returnType}>(Method::${httpMethod}, "${path}", None::<&()>).await`);
    }

    lines.push('    }');

    return lines.join('\n');
  }

  /**
   * Generate error.rs
   */
  private generateErrorRs(): string {
    const lines: string[] = [];

    lines.push('//! Error types');
    lines.push('//!');
    lines.push('//! Auto-generated by LLM-Forge. Do not edit manually.');
    lines.push('');
    lines.push('use std::fmt;');
    lines.push('');

    lines.push('/// Error type');
    lines.push('#[derive(Debug)]');
    lines.push('pub enum Error {');
    lines.push('    /// HTTP request error');
    lines.push('    Request(reqwest::Error),');
    lines.push('    /// API error response');
    lines.push('    ApiError {');
    lines.push('        /// HTTP status code');
    lines.push('        status: u16,');
    lines.push('        /// Error message');
    lines.push('        message: String,');
    lines.push('    },');
    lines.push('}');
    lines.push('');

    lines.push('impl fmt::Display for Error {');
    lines.push('    fn fmt(&self, f: &mut fmt::Formatter<\'_>) -> fmt::Result {');
    lines.push('        match self {');
    lines.push('            Error::Request(e) => write!(f, "Request error: {}", e),');
    lines.push('            Error::ApiError { status, message } => {');
    lines.push('                write!(f, "API error ({}): {}", status, message)');
    lines.push('            }');
    lines.push('        }');
    lines.push('    }');
    lines.push('}');
    lines.push('');

    lines.push('impl std::error::Error for Error {}');
    lines.push('');

    lines.push('impl From<reqwest::Error> for Error {');
    lines.push('    fn from(err: reqwest::Error) -> Self {');
    lines.push('        Error::Request(err)');
    lines.push('    }');
    lines.push('}');
    lines.push('');

    lines.push('/// Result type alias');
    lines.push('pub type Result<T> = std::result::Result<T, Error>;');

    return lines.join('\n');
  }

  /**
   * Generate Cargo.toml
   */
  override async generateManifest(): Promise<GeneratedFile> {
    const packageName = this.toSnakeCase(this.options.packageName);

    const lines: string[] = [];

    lines.push('[package]');
    lines.push(`name = "${packageName}"`);
    lines.push(`version = "${this.options.packageVersion}"`);
    lines.push('edition = "2021"');
    lines.push(`license = "${this.options.license}"`);
    if (this.schema.metadata.metadata?.['description']) {
      lines.push(`description = "${this.schema.metadata.metadata?.['description']}"`);
    }
    lines.push('');

    lines.push('[dependencies]');
    lines.push('reqwest = { version = "0.11", features = ["json"] }');
    lines.push('serde = { version = "1.0", features = ["derive"] }');
    lines.push('serde_json = "1.0"');
    lines.push('tokio = { version = "1.0", features = ["full"] }');
    lines.push('');

    lines.push('[dev-dependencies]');
    lines.push('tokio-test = "0.4"');

    return {
      path: 'Cargo.toml',
      content: lines.join('\n'),
    };
  }

  /**
   * Generate README
   */
  protected async generateReadme(): Promise<GeneratedFile> {
    const packageName = this.toSnakeCase(this.options.packageName);
    const lines: string[] = [];

    lines.push(`# ${this.schema.metadata.providerName} Rust SDK`);
    lines.push('');
    if (this.schema.metadata.metadata?.['description']) {
      lines.push(String(this.schema.metadata.metadata?.['description']));
      lines.push('');
    }
    lines.push('Auto-generated by LLM-Forge.');
    lines.push('');

    lines.push('## Installation');
    lines.push('');
    lines.push('Add to your `Cargo.toml`:');
    lines.push('');
    lines.push('```toml');
    lines.push('[dependencies]');
    lines.push(`${packageName} = "${this.options.packageVersion}"`);
    lines.push('```');
    lines.push('');

    lines.push('## Usage');
    lines.push('');
    lines.push('```rust');
    lines.push(`use ${packageName}::Client;`);
    lines.push('');
    lines.push('#[tokio::main]');
    lines.push('async fn main() {');
    lines.push('    let client = Client::new("your-api-key");');
    lines.push('    // Use the client...');
    lines.push('}');
    lines.push('```');

    return {
      path: 'README.md',
      content: lines.join('\n'),
    };
  }

  /**
   * Generate examples
   */
  override async generateExamples(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];
    const packageName = this.toSnakeCase(this.options.packageName);

    const lines: string[] = [];
    lines.push(`use ${packageName}::Client;`);
    lines.push('');
    lines.push('#[tokio::main]');
    lines.push('async fn main() -> Result<(), Box<dyn std::error::Error>> {');
    lines.push('    let client = Client::new("your-api-key");');
    lines.push('');
    lines.push('    // Example API call');
    lines.push('    // let response = client.some_method(&request).await?;');
    lines.push('');
    lines.push('    Ok(())');
    lines.push('}');

    files.push({
      path: 'examples/basic.rs',
      content: lines.join('\n'),
    });

    return files;
  }

  /**
   * Generate tests
   */
  override async generateTests(): Promise<GeneratedFile[]> {
    const files: GeneratedFile[] = [];

    const lines: string[] = [];
    lines.push('#[cfg(test)]');
    lines.push('mod tests {');
    lines.push('    use super::*;');
    lines.push('');
    lines.push('    #[test]');
    lines.push('    fn test_client_creation() {');
    lines.push('        let client = Client::new("test-key");');
    lines.push('        assert!(true);');
    lines.push('    }');
    lines.push('}');

    files.push({
      path: 'src/tests.rs',
      content: lines.join('\n'),
    });

    return files;
  }
}
